###### 词法分析测试：

```
# 编译出来一个包含所有依赖的 Jar (Java 存档包) 文件
gradle fatjar
java -jar build/libs/miniplc0java.jar -t  hello.plc0 -o output_t.txt
java -jar build/libs/miniplc0java.jar -l  hello.plc0 -o output_l.txt


java -jar build/libs/miniplc0java.jar -t  1.c -o out1.txt
java -jar build/libs/miniplc0java.jar -l  1.c -o out1.txt
```

###### 

```java
	Pos ptrNext = new Pos(0, 0);//下一字符的位置
    Pos ptr = new Pos(0, 0);//当前字符
    boolean initialized = false;
    Optional<Character> peeked = Optional.empty();//下一个字符
public char nextChar() {
        if (this.peeked.isPresent()) {
            char ch = this.peeked.get();
            this.peeked = Optional.empty();
            this.ptr = ptrNext;
            return ch;
        } else {
            char ch = this.getNextChar();
            this.ptr = ptrNext;
            return ch;
        }
    }
public char peekChar() {
        if (peeked.isPresent()) {
            return peeked.get();
        } else {
            char ch = getNextChar();
            this.peeked = Optional.of(ch);
            return ch;
        }
    }
private char getNextChar() {
        if (isEOF()) {
            return 0;
        }
        char result = linesBuffer.get(ptrNext.row).charAt(ptrNext.col);
        ptrNext = nextPos();
        return result;
    }
public Pos nextPos() {
        if (ptr.row >= linesBuffer.size()) {
            throw new Error("advance after EOF");
        }
        if (ptr.col == linesBuffer.get(ptr.row).length() - 1) {
            return new Pos(ptr.row + 1, 0);
        }
        return new Pos(ptr.row, ptr.col + 1);
}
public boolean isPresent() {
        return value != null;
}
```



###### 语法分析：

```c
/** 当前偷看的 token */Token peekedToken = null;
/** 符号表 */HashMap<String, SymbolEntry> symbolTable = new HashMap<>();
/** 下一个变量的栈偏移 */int nextOffset = 0;
public char nextChar() /*将指针指向下一个字符，并返回当前字符*/
public char peekChar()/*查看下一个字符，但不移动指针*/
Token next()//输出并前进一个 token。
Token peek()//偷看下一个 token。多次调用 peek() 会返回同一个 token，调用 peek 后第一次调用 next 会返回与之前相同的 token。
boolean check(TokenType tt)//偷看下一个 token，如果类型与 tt 相同则返回 true，否则返回 false。
Token nextIf(TokenType tt)//偷看下一个 token，如果 token 的类型与 tt 相同则前进一个 token 并返回它，否则返回 null。相当于先调用 check 再调用 next。
Token expect(TokenType tt)//期待下一个 token 的类型与 tt 相同。如果相同则返回这个 token，否则直接抛出异常。相当于会抛异常版的 nextIf。

//定位 
public Pos previousPos()/* 获取上一个字符的位置*/
public Pos currentPos()/* 获取当前字符的位置*/
public Pos nextPos()/*获取下一个字符的位置*/
//示例  |01234
//示例  |apple 位置为-1到4
    
<关键字> ::= 'begin' | 'end' | 'const' | 'var' | 'print'
//analyseProgram()
<程序> ::= 'begin'<主过程>'end'

//1 analyseMain()
<主过程> ::= <常量声明><变量声明><语句序列>

//2 analyseConstantDeclaration()
<常量声明> ::= {<常量声明语句>}
<常量声明语句> ::= 'const'<标识符>'='<常表达式>';'
<常表达式> ::= [<符号>]<无符号整数> //a 

//3 analyseVariableDeclaration()
<变量声明> ::= {<变量声明语句>}
<变量声明语句> ::= 'var'<标识符>['='<表达式>]';' 

//4 analyseStatementSequence()
<语句序列> ::= {<语句>}
<语句> ::= <赋值语句>|<输出语句>|<空语句>
<赋值语句> ::= <标识符>'='<表达式>';' //analyseAssignmentStatement();
<输出语句> ::= 'print' '(' <表达式> ')' ';'//analyseOutputStatement();
<空语句> ::= ';'

//5 analyseExpression()
<表达式> ::= <项>{<加法型运算符><项>}
<项> ::= <因子>{<乘法型运算符><因子>}  //（1）
<因子> ::= [<符号>]( <标识符> | <无符号整数> | '('<表达式>')' )//（2）

<加法型运算符> ::= '+'|'-'
<乘法型运算符> ::= '*'|'/'
```



- 非终结符由一段由字母、数字或下划线组成的字符串表示
- 终结符包括字符串、字符范围和正则表达式
- 正则表示
  - \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
  - ？：0-1      +：1-∞      *：0-∞
    - `{m}` 表示指定重复 `m` 次；`{m,n}` 表示重复 `m` 到 `n` 次；
    - `{m,}` 表示重复 `m` 次及以上；`{,n}` 表示重复 0 到 `n` 次；

```c
// ## 关键字
FN_KW     -> 'fn' //函数
LET_KW    -> 'let' //定义
CONST_KW  -> 'const'
AS_KW     -> 'as'
WHILE_KW  -> 'while'
IF_KW     -> 'if'
ELSE_KW   -> 'else'
RETURN_KW -> 'return'
BREAK_KW  -> 'break'
CONTINUE_KW -> 'continue'

// ## 字面量
digit -> [0-9] UINT_LITERAL -> digit+
DOUBLE_LITERAL -> digit+ '.' digit+ ([eE] digit+)?//1.1 e/E (+/-)数字

// ""里面可以是\'、\"、\\、\n、\t、\r 不能是\,\\\,",空白
escape_sequence -> '\' [\\"'nrt] //转义序列：双引号 "、反斜线 \\、空白符 \r \n \t 
string_regular_char -> [^"\\]  
STRING_LITERAL -> '"' (string_regular_char | escape_sequence)* 
                        
char_regurhelar_char -> [^'\\]
CHAR_LITERAL -> '\'' (char_regular_char | escape_sequence) '\'' //普通字符或转义字符 \' \'

// ## 标识符
IDENT -> [_a-zA-Z] [_a-zA-Z0-9]*

// ## 符号
PLUS      -> '+'
MINUS     -> '-'
MUL       -> '*'
DIV       -> '/'
ASSIGN    -> '='
EQ        -> '=='
NEQ       -> '!='
LT        -> '<'
GT        -> '>'
LE        -> '<='
GE        -> '>='
L_PAREN   -> '('
R_PAREN   -> ')'
L_BRACE   -> '{'
R_BRACE   -> '}'
ARROW     -> '->'
COMMA     -> ','
COLON     -> ':'
SEMICOLON -> ';'

// ## 注释
COMMENT -> '//' regex(.*) '\n'

// # 表达式
expr -> 
      operator_expr
    | negate_expr
    | assign_expr
    | as_expr
    | call_expr
    | literal_expr
    | ident_expr
    | group_expr

binary_operator -> '+' | '-' | '*' | '/' | '==' | '!=' | '<' | '>' | '<=' | '>='
operator_expr -> expr binary_operator expr
negate_expr -> '-' expr
assign_expr -> l_expr '=' expr
as_expr -> expr 'as' ty
call_param_list -> expr (',' expr)*
call_expr -> IDENT '(' call_param_list? ')'
literal_expr -> UINT_LITERAL | DOUBLE_LITERAL | STRING_LITERAL | CHAR_LITERAL
ident_expr -> IDENT
group_expr -> '(' expr ')'

// ## 左值表达式
l_expr -> IDENT
// ## 类型
ty -> IDENT
// # 语句
stmt ->
      expr_stmt
    | decl_stmt
    | if_stmt
    | while_stmt
    | break_stmt
    | continue_stmt
    | return_stmt
    | block_stmt
    | empty_stmt

expr_stmt -> expr ';'

let_decl_stmt -> 'let' IDENT ':' ty ('=' expr)? ';'
const_decl_stmt -> 'const' IDENT ':' ty '=' expr ';'
decl_stmt -> let_decl_stmt | const_decl_stmt

if_stmt -> 'if' expr block_stmt ('else' 'if' expr block_stmt)* ('else' block_stmt)?
while_stmt -> 'while' expr block_stmt
break_stmt -> 'break' ';'
continue_stmt -> 'continue' ';'
return_stmt -> 'return' expr? ';'
block_stmt -> '{' stmt* '}'
empty_stmt -> ';'

// # 函数
function_param -> 'const'? IDENT ':' ty
function_param_list -> function_param (',' function_param)*
function -> 'fn' IDENT '(' function_param_list? ')' '->' ty block_stmt

// # 程序
item -> function | decl_stmt
program -> item*
```



```c
- program -> item*
- item -> function | decl_stmt //函数|
  - function -> 'fn' IDENT '(' function_param_list? ')' '->' ty block_stmt
    - function_param_list -> function_param (',' function_param)*
      - function_param -> 'const'? IDENT ':' ty
  -  decl_stmt -> let_decl_stmt | const_decl_stmt
    - const_decl_stmt -> 'const' IDENT ':' ty '=' expr ';'
    - let_decl_stmt -> 'let' IDENT ':' ty ('=' expr)? ';'
    
- stmt -> expr_stmt|decl_stmt|if_stmt| while_stmt| break_stmt| continue_stmt| return_stmt|block_stmt|empty_stmt
  - expr_stmt -> expr ';'//表达式语句
  - decl_stmt -> let_decl_stmt | const_decl_stmt
    - let_decl_stmt -> 'let' IDENT ':' ty ('=' expr)? ';'//声明变量
    - const_decl_stmt -> 'const' IDENT ':' ty '=' expr ';'//声明常量
  - if_stmt -> 'if' expr block_stmt ('else' 'if' expr block_stmt)* ('else' block_stmt)?//if语句
  - while_stmt -> 'while' expr block_stmt//while 语句代表一组可以重复执行的语句。
  - break_stmt -> 'break' ';'
  - continue_stmt -> 'continue' ';'
  - return_stmt -> 'return' expr? ';'
  - block_stmt -> '{' stmt* '}'
  - empty_stmt -> ';'
    
//Vt
//运算符：{'+' | '-' | '*' | '/' | '==' | '!=' | '<' | '>' | '<=' | '>='|'(' expr ')'}
//赋值与转换：{'='| IDENT|'as'}
//函数调用：{'('|')'|','}
- expr -> operator_expr| negate_expr| assign_expr | as_expr| call_expr| literal_expr| ident_expr |group_expr
  - operator_expr -> expr binary_operator expr
    - binary_operator -> '+' | '-' | '*' | '/' | '==' | '!=' | '<' | '>' | '<=' | '>='
  - negate_expr -> '-' expr//取反表达式
    
  - assign_expr -> l_expr '=' expr//赋值表达式 
    - l_expr -> IDENT//左值表达式是一个局部或全局的变量名。
  - as_expr -> expr 'as' ty//表达式`as`类型 将左侧表达式表示的值转换成右侧类型表示的值。整数 `int` 和浮点数 `double` 之间的互相转换。
    
  - call_expr -> IDENT '(' call_param_list? ')'//函数调用表达式
    
    - call_param_list -> expr (',' expr)*// *调用参数列表* 函数必须在调用前声明过，特殊情况标准库中的函数在调用前不需要声明
  - literal_expr -> UINT_LITERAL | DOUBLE_LITERAL | STRING_LITERAL | CHAR_LITERAL//字面量
    - UINT_LITERAL -> digit+ //数字
    - DOUBLE_LITERAL -> digit+ '.' digit+ ([eE] digit+)? //double
    - string_regular_char -> [^"\\] //char
    - STRING_LITERAL -> '"' (string_regular_char | escape_sequence)* '"'//字符串
    	- escape_sequence -> '\' [\\"'nrt]
  - ident_expr -> IDENT //标识符表达式 局部或全局变量
  - group_expr -> '(' expr ')' //括号表达式内部的表达式的值将被优先计算。
- ty -> IDENT
```

